[TOC]

# ğŸ“˜ ==æ“ä½œç³»ç»Ÿè€ƒç‚¹==

- ğŸ§  è¿›ç¨‹ã€çº¿ç¨‹åŸºæœ¬æ¦‚å¿µï¼ŒPCB, Context, è¿›/çº¿ç¨‹çŠ¶æ€åŠè½¬æ¢ï¼Œè¿›ç¨‹é—´IPCæ–¹å¼ã€‚
- âš™ï¸ CPUè¿›ç¨‹è°ƒåº¦ç®—æ³•ï¼ŒFCFS, SJF, RR, Priority
- ğŸ” çº¿ç¨‹åŒæ­¥åŸç†ä¸æ–¹æ³•, Petersonã€äº’æ–¥é”ã€ä¿¡å·é‡ç­‰ï¼ŒåŸç†çš„ä¼ªä»£ç 
- âŒ æ­»é”é¢„é˜²å’Œé¿å…ï¼Œé“¶è¡Œå®¶ç®—æ³•
- ğŸ’¾ å†…å­˜åŸºæœ¬æ¦‚å¿µï¼Œè™šæ‹Ÿå†…å­˜ï¼Œé¡µ/å¸§

ğŸ“– ä»¥ä¸‹å†…å®¹å‡åŸºäºè¯¾ä»¶ã€Šæ“ä½œç³»ç»Ÿæ¦‚å¿µã€‹ï¼ˆSilberschatz ç­‰ï¼Œ2018ï¼‰ä¸­çš„ç›¸å…³ç« èŠ‚ï¼Œåˆ†åˆ«ç»™å‡ºä¸­æ–‡ä¸è‹±æ–‡ç‰ˆæœ¬çš„è§£é‡Šã€‚



------

## 1. ğŸ§µ è¿›ç¨‹ã€çº¿ç¨‹åŸºæœ¬æ¦‚å¿µï¼›ğŸ“¦ PCBã€ğŸ§  ä¸Šä¸‹æ–‡ï¼›ğŸ“Š è¿›/çº¿ç¨‹çŠ¶æ€åŠè½¬æ¢ï¼›ğŸ“¨ è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCæ–¹å¼ï¼‰

### ä¸­æ–‡

- **è¿›ç¨‹ï¼ˆProcessï¼‰**ï¼šç¨‹åºåœ¨æ‰§è¡ŒæœŸé—´çš„å®ä½“ï¼Œå…·æœ‰è‡ªå·±çš„åœ°å€ç©ºé—´ã€ç¨‹åºè®¡æ•°å™¨ã€å¯„å­˜å™¨å’Œèµ„æºç­‰ï¼Œæ˜¯ç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…å’Œè°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚
- **çº¿ç¨‹ï¼ˆThreadï¼‰**ï¼šè¿›ç¨‹çš„æœ€å°æ‰§è¡Œå•å…ƒï¼Œä¹Ÿç§°è½»é‡çº§è¿›ç¨‹ã€‚
- **è¿›ç¨‹æ§åˆ¶å—ï¼ˆPCBï¼‰**ï¼šç³»ç»Ÿä¸ºæ¯ä¸ªè¿›ç¨‹ç»´æŠ¤çš„ä¸€å¼ è¡¨ï¼Œè®°å½•è¯¥è¿›ç¨‹çš„çŠ¶æ€ã€ç¨‹åºè®¡æ•°å™¨ã€CPU å¯„å­˜å™¨ã€è°ƒåº¦ä¿¡æ¯ã€å†…å­˜ç®¡ç†ä¿¡æ¯ã€I/O çŠ¶æ€ç­‰ã€‚ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶å³ä¿å­˜/æ¢å¤ PCB ä¸­çš„ä¿¡æ¯ã€‚
- **çŠ¶æ€åŠè½¬æ¢**ï¼šè¿›ç¨‹åœ¨â€œæ–°å»ºï¼ˆnewï¼‰â†’å°±ç»ªï¼ˆreadyï¼‰â†’è¿è¡Œï¼ˆrunningï¼‰â†’ç­‰å¾…/é˜»å¡ï¼ˆwaitingï¼‰â†’ç»ˆæ­¢ï¼ˆterminatedï¼‰â€ç­‰çŠ¶æ€é—´è½¬æ¢ã€‚è°ƒåº¦ä¸ä¸­æ–­æ˜¯ä¸»è¦è§¦å‘å› ç´ ã€‚
- **è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰**ï¼š
    - ğŸ§± **å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰**ï¼šå¤šä¸ªè¿›ç¨‹æ˜ å°„åŒä¸€å—ç‰©ç†å†…å­˜ï¼Œé€šè¿‡è¯»å†™å†…å­˜äº¤æ¢æ•°æ®ã€‚
    - âœ‰ï¸ **æ¶ˆæ¯ä¼ é€’ï¼ˆMessage Passingï¼‰**ï¼šé€šè¿‡ `send/receive` åŸè¯­ï¼Œåœ¨å†…æ ¸ç©ºé—´æˆ–ç”¨æˆ·ç©ºé—´çš„ä¿¡ç®±/ç«¯å£é—´å‘é€å›ºå®šæˆ–å¯å˜é•¿åº¦æ¶ˆæ¯ã€‚

### English

- **Process**: An active entity representing a program in execution; it includes its own address space, program counter, registers, and resources, and is the fundamental unit for resource allocation and scheduling.
- **Thread**: A thread (lightweight process) is the smallest unit of execution within a process.
- **PCB (Process Control Block)**: A data structure used by the OS to store all information about a process. During a context switch, the PCB contents are saved and restored.
- **States & Transitions**: A process transitions among New â†’ Ready â†’ Running â†’ Waiting/Blocked â†’ Terminated; events such as dispatch, I/O completion, and interrupts trigger transitions.
- **IPC (Interprocess Communication)**:
    - ğŸ§± **Shared Memory**: Processes map a common physical memory region into their address spaces and exchange data by direct reads and writes to that region.
    - âœ‰ï¸ **Message Passing**: Processes communicate by executing primitives such as `send(P, msg)` / `receive(Q, msg)` through mailboxes (ports) or queues managed by the OS, enabling both data exchange and synchronization.



------

## 2. âš™ï¸ CPU è¿›ç¨‹è°ƒåº¦ç®—æ³•ï¼šFCFSã€SJFã€RRã€Priority

### ä¸­æ–‡

- **å…ˆæ¥å…ˆæœåŠ¡ï¼ˆFCFSï¼‰**ï¼šğŸ“¥ æŒ‰åˆ°è¾¾é¡ºåºè°ƒåº¦ï¼Œç®€å•ä½†å¯èƒ½å¯¼è‡´â€œé˜Ÿé•¿æ•ˆåº”â€ï¼Œå¹³å‡ç­‰å¾…æ—¶é—´ä¸ä¸€å®šæœ€ä¼˜ã€‚
- **çŸ­ä½œä¸šä¼˜å…ˆï¼ˆSJFï¼‰**ï¼šâ± é€‰æ‹©ä¸‹ä¸€ä¸ª CPU éœ€æ±‚æœ€çŸ­çš„ä½œä¸šï¼Œæœ€ä¼˜å¹³å‡ç­‰å¾…æ—¶é—´ï¼Œä½†éœ€è¦ä¼°è®¡ä¸‹ä¸€æ¬¡ CPU æ—¶é—´ï¼Œå¯é€šè¿‡æŒ‡æ•°å¹³æ»‘æ³•é¢„æµ‹ã€‚
- **æ—¶é—´ç‰‡è½®è½¬ï¼ˆRRï¼‰**ï¼šğŸ”„ ä¸ºæ¯ä¸ªå°±ç»ªè¿›ç¨‹åˆ†é…å›ºå®šæ—¶é—´ç‰‡ï¼ˆqï¼‰ï¼Œæ—¶é—´ç‰‡è€—å°½ååˆ‡æ¢åˆ°ä¸‹ä¸€è¿›ç¨‹ï¼Œå“åº”æ—¶é—´å¥½ï¼Œè°ƒåº¦å¼€é”€ä¸ q å¤§å°ç›¸å…³ã€‚
- **ä¼˜å…ˆçº§è°ƒåº¦ï¼ˆPriorityï¼‰**ï¼šğŸ· æ¯ä¸ªè¿›ç¨‹èµ‹äºˆä¼˜å…ˆçº§ï¼Œè°ƒåº¦ä¼˜å…ˆçº§æœ€é«˜çš„è¿›ç¨‹ï¼›å¯èƒ½å‡ºç°é¥¥é¥¿ï¼Œå¯é€šè¿‡â€œè€åŒ–â€ï¼ˆAgingï¼‰æé«˜ç­‰å¾…è¿›ç¨‹ä¼˜å…ˆçº§ã€‚

### English

- **FCFS (First-Come, First-Served)**: ğŸ“¥ Schedules processes in arrival order; simple but suffers from convoy effect, and average waiting time may be suboptimal.
- **SJF (Shortest-Job-First)**: â± Schedules the process with the smallest next CPU burst; yields optimal average waiting time but requires prediction (e.g., exponential averaging).
- **RR (Round Robin)**: ğŸ”„ Allocates each ready process a time quantum `q`; preemptive scheduling rotates through processes in fixed slices, improving responsiveness but increasing context-switch overhead if `q` is too small.
- **Priority Scheduling**: ğŸ· Assigns each process a priority number; CPU given to highest-priority process. Starvation possible; Aging technique can gradually raise priority of waiting processes.



------

## 3. ğŸ” çº¿ç¨‹åŒæ­¥åŸç†ä¸æ–¹æ³•ï¼šPetersonã€äº’æ–¥é”ã€ä¿¡å·é‡ç­‰ï¼ŒåŸç†çš„ä¼ªä»£ç 

### ä¸­æ–‡

1. **Peterson ç®—æ³•ï¼ˆä¸¤çº¿ç¨‹ï¼‰**ï¼šğŸ§  åˆ©ç”¨ `flag[2]` å’Œ `turn` å˜é‡ï¼Œå®ç°äº’æ–¥ä¸”æ»¡è¶³è¿›åº¦ä¸æœ‰é™ç­‰å¾…ã€‚

    ```c
    /* Petersonâ€™s Solution (for two processes P_i and P_j) */
    while (true) {
        flag[i] = true;      // è¡¨ç¤º P_i æƒ³è¿›å…¥ä¸´ç•ŒåŒº  
        turn = j;            // è¡¨ç¤ºè®© P_j å…ˆè¡Œ  
        while (flag[j] && turn == j)
            ;                // ç­‰å¾…ï¼šå¦‚æœ P_j ä¹Ÿæƒ³è¿›å…¥ä¸”è½®åˆ° P_jï¼Œåˆ™è‡ªæ—‹  
        /* critical section */  // ä¸´ç•ŒåŒº  
        flag[i] = false;     // ç¦»å¼€ä¸´ç•ŒåŒºï¼Œå…è®¸å¯¹æ–¹è¿›å…¥  
        /* remainder section */ // å…¶ä½™éƒ¨åˆ†  
    }
    ```

2. **Test-and-Set åŸè¯­**ï¼šâš™ï¸ åŸå­æ‰§è¡Œï¼Œè¿”å›æ—§å€¼å¹¶å°†é”ç½®ä¸º trueï¼Œå®ç°ç®€å•è‡ªæ—‹é”ã€‚

```c
do {
  while (test_and_set(&lock));
  // ä¸´ç•ŒåŒº
  lock = false;
} while (true);
```

1. **äº’æ–¥é”ï¼ˆMutexï¼‰**ï¼šğŸ”’ å°è£… acquire()/release() æ¥å£ï¼Œé€šå¸¸åŸºäºåº•å±‚åŸå­æŒ‡ä»¤ï¼Œä»å¯èƒ½è‡ªæ—‹ã€‚

```c
/* Solution to CS Problem Using Mutex Locks (spinlock version) */
while (true) {
    acquire lock;        // è·å–äº’æ–¥é”ï¼ˆå¿™ç­‰å¾…ç›´åˆ°é”å¯ç”¨ï¼‰  
    /* critical section */  // ä¸´ç•ŒåŒº  
    release lock;        // é‡Šæ”¾äº’æ–¥é”  
    /* remainder section */ // å…¶ä½™éƒ¨åˆ†  
}
```

1. **ä¿¡å·é‡ï¼ˆSemaphoreï¼‰**ï¼šğŸ“¶ æ•´å‹å˜é‡ï¼Œä»…é€šè¿‡åŸå­ `wait()`ï¼ˆPï¼‰å’Œ `signal()`ï¼ˆVï¼‰æ“ä½œè®¿é—®ï¼Œå®ç°é˜»å¡/å”¤é†’ã€‚

```c
/* Semaphore S busy-waiting version */
// P(S) æ“ä½œ
wait(S) {
    while (S <= 0)      // å½“ä¿¡å·é‡éæ­£æ—¶ï¼Œå¿™ç­‰å¾…  
        ;               // do nothing  
    S--;                // è·å–èµ„æºï¼Œä¿¡å·é‡å‡ä¸€  
}

// V(S) æ“ä½œ
signal(S) {
    S++;                // é‡Šæ”¾èµ„æºï¼Œä¿¡å·é‡åŠ ä¸€  
}
```

### English

1. **Petersonâ€™s Solution (2 threads)**: ğŸ§  Uses `flag[2]` and `turn` to enforce mutual exclusion, progress, and bounded waiting.

    ```c
    /* Petersonâ€™s Solution (for two processes P_i and P_j) */
    while (true) {
        flag[i] = true;      // è¡¨ç¤º P_i æƒ³è¿›å…¥ä¸´ç•ŒåŒº  
        turn = j;            // è¡¨ç¤ºè®© P_j å…ˆè¡Œ  
        while (flag[j] && turn == j)
            ;                // ç­‰å¾…ï¼šå¦‚æœ P_j ä¹Ÿæƒ³è¿›å…¥ä¸”è½®åˆ° P_jï¼Œåˆ™è‡ªæ—‹  
        /* critical section */  // ä¸´ç•ŒåŒº  
        flag[i] = false;     // ç¦»å¼€ä¸´ç•ŒåŒºï¼Œå…è®¸å¯¹æ–¹è¿›å…¥  
        /* remainder section */ // å…¶ä½™éƒ¨åˆ†  
    }
    ```

2. **Mutex Lock**: ğŸ”’ Provides `acquire()`/`release()` APIs, implemented via atomic instructions; may busy-wait (spinlock).

```c
/* Solution to CS Problem Using Mutex Locks (spinlock version) */
while (true) {
    acquire lock;        // è·å–äº’æ–¥é”ï¼ˆå¿™ç­‰å¾…ç›´åˆ°é”å¯ç”¨ï¼‰  
    /* critical section */  // ä¸´ç•ŒåŒº  
    release lock;        // é‡Šæ”¾äº’æ–¥é”  
    /* remainder section */ // å…¶ä½™éƒ¨åˆ†  
}
```

1. **Semaphore**: ğŸ“¶ Integer counter with atomic `wait()` (P) and `signal()` (V) operations, enabling blocking and wake-up semantics.

```c
/* Semaphore S busy-waiting version */
// P(S) æ“ä½œ
wait(S) {
    while (S <= 0)      // å½“ä¿¡å·é‡éæ­£æ—¶ï¼Œå¿™ç­‰å¾…  
        ;               // do nothing  
    S--;                // è·å–èµ„æºï¼Œä¿¡å·é‡å‡ä¸€  
}

// V(S) æ“ä½œ
signal(S) {
    S++;                // é‡Šæ”¾èµ„æºï¼Œä¿¡å·é‡åŠ ä¸€  
}
```



------

### è¿˜æœ‰ä¸€äº›ä¸æ€ä¹ˆé‡è¦çš„

**â€œçº¿ç¨‹åŒæ­¥åŸç†ä¸æ–¹æ³•ï¼šPetersonã€äº’æ–¥é”ã€ä¿¡å·é‡ç­‰ï¼ŒåŸç†çš„ä¼ªä»£ç â€**ä¸­ï¼Œâ€œç­‰â€ è¡¨ç¤ºä¸æ­¢è¿™ä¸‰ç§æ–¹å¼ã€‚ç¬¬ 6 ç« ä¸­è¿˜åŒ…æ‹¬ä»¥ä¸‹çº¿ç¨‹åŒæ­¥æ–¹æ³•ï¼š

**ä¸­æ–‡ï¼š**
 é™¤äº† Peterson ç®—æ³•ã€äº’æ–¥é”å’Œä¿¡å·é‡å¤–ï¼Œè¯¾ä»¶ä¸­è¿˜ä»‹ç»äº†å…¶ä»–åŒæ­¥åŸè¯­ï¼š

- ğŸ“´ å…³é—­ä¸­æ–­ï¼ˆä»…é™å•æ ¸ï¼‰
- ğŸ” Test-and-Set åŸå­æŒ‡ä»¤ï¼ˆæ„å»ºè‡ªæ—‹é”ï¼‰
- ğŸ”„ Compare-and-Swap åŸè¯­ï¼ˆCASï¼‰
     è¿™äº›æ–¹æ³•ä¹Ÿå¯ç”¨äºçº¿ç¨‹åŒæ­¥ã€‚

**English:**
 In addition to Petersonâ€™s algorithm, mutex locks, and semaphores, the lecture also introduces:

- ğŸ“´ **Disabling Interrupts** (only on uniprocessor systems)
- ğŸ” **Test-and-Set Instruction** (used to build spinlocks)
- ğŸ”„ **Compare-and-Swap** (CAS primitive)
     These are also viable low-level synchronization mechanisms.

------

âœ… **Test-and-Set Lockï¼ˆæµ‹è¯•å¹¶è®¾ç½®é”ï¼Œè‡ªæ—‹é”ï¼‰**

è¯¾ä»¶åŸæ–‡ä»£ç å¦‚ä¸‹ï¼ˆç¬¬ 6.18 é¡µï¼‰ï¼š

```c
do {
    while (test_and_set(&lock))
        ;                // busy wait
    /* critical section */
    lock = false;
    /* remainder section */
} while (true);
```

- `test_and_set()` æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œè¿”å›æ—§å€¼å¹¶å°† lock è®¾ç½®ä¸º trueã€‚
- å¦‚æœé”å·²è¢«å ç”¨ï¼ˆè¿”å› trueï¼‰ï¼Œåˆ™çº¿ç¨‹ç»§ç»­è‡ªæ—‹ç­‰å¾…ã€‚

------

âœ… **Compare-and-Swapï¼ˆCAS åŸå­æ“ä½œï¼‰**

è¯¾ä»¶ç¬¬ 6.19 é¡µä»‹ç»äº† CAS åŸè¯­åŠå…¶ä¼ªä»£ç å®ç°ï¼š

```c
do {
    while (!compare_and_swap(&lock, 0, 1))
        ;               // busy wait
    /* critical section */
    lock = 0;
    /* remainder section */
} while (true);
```

- `compare_and_swap(ptr, expected, new)`ï¼š
    - å¦‚æœ `*ptr == expected`ï¼Œåˆ™å°† `*ptr` è®¾ä¸º `new` å¹¶è¿”å› trueï¼›
    - å¦åˆ™ä¸ä¿®æ”¹ï¼Œè¿”å› falseã€‚

------

âœ… **Disabling Interruptsï¼ˆå…³é—­ä¸­æ–­ï¼‰**

åœ¨å•å¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œå¯ä»¥ä½¿ç”¨å…³é—­ä¸­æ–­æ–¹æ³•å®ç°åŒæ­¥ï¼ˆç¬¬ 6.14 é¡µï¼‰ï¼š

```c
disable interrupts;
/* critical section */
enable interrupts;
```

- ç¼ºç‚¹ï¼šä»…é€‚ç”¨äºå•æ ¸ç³»ç»Ÿï¼Œåœ¨å¤šæ ¸ç¯å¢ƒä¸­æ— æ³•é˜»æ­¢å…¶ä»– CPU å¹¶å‘æ‰§è¡Œã€‚



------

## 4. âŒ æ­»é”é¢„é˜²å’Œé¿å…ï¼›é“¶è¡Œå®¶ç®—æ³•

### ä¸­æ–‡

- **æ­»é”çš„å››ä¸ªå¿…è¦æ¡ä»¶**ï¼š

    1. ğŸ”’ äº’æ–¥ï¼ˆæ¯ä¸ªèµ„æºä¸€æ¬¡åªèƒ½è¢«ä¸€ä¸ªçº¿ç¨‹å æœ‰ï¼‰
    2. ğŸ”„ å æœ‰ä¸”ç­‰å¾…ï¼ˆçº¿ç¨‹æŒæœ‰èµ„æºçš„åŒæ—¶å†ç”³è¯·å…¶ä»–èµ„æºï¼‰
    3. ğŸš« ä¸å‰¥å¤ºï¼ˆå·²åˆ†é…èµ„æºåªæœ‰çº¿ç¨‹ä¸»åŠ¨é‡Šæ”¾æ‰å¯å›æ”¶ï¼‰
    4. ğŸ” å¾ªç¯ç­‰å¾…ï¼ˆå­˜åœ¨çº¿ç¨‹é›†åˆ Tâ‚€â†’Tâ‚â†’â€¦â†’Tâ‚™ï¼ŒTâ‚€ ç­‰å¾… Tâ‚ å ç”¨çš„èµ„æºâ€¦Tâ‚™ ç­‰å¾… Tâ‚€ å ç”¨çš„èµ„æºï¼‰

- **æ­»é”é¢„é˜²**ï¼šâš ï¸ ç ´åä¸Šè¿°å››ä¸ªæ¡ä»¶ä¸­çš„è‡³å°‘ä¸€é¡¹

    - âœ‹ ç ´åå æœ‰ä¸”ç­‰å¾…ï¼šçº¿ç¨‹å¿…é¡»ä¸€æ¬¡æ€§ç”³è¯·æ‰€éœ€æ‰€æœ‰èµ„æºï¼Œæˆ–åªæœ‰åœ¨ä¸æŒæœ‰ä»»ä½•èµ„æºæ—¶æ‰èƒ½ç”³è¯·æ–°èµ„æº
    - ğŸ”ƒ ç ´åä¸å‰¥å¤ºï¼šè‹¥èµ„æºç”³è¯·å¤±è´¥ï¼Œåˆ™é‡Šæ”¾å·²æŒæœ‰èµ„æºï¼Œå¾…å…¨éƒ¨æ‰€éœ€èµ„æºå¯ç”¨æ—¶å†é‡è¯•
    - ğŸ§® ç ´åå¾ªç¯ç­‰å¾…ï¼šä¸ºæ‰€æœ‰èµ„æºç±»å‹ç¼–å·ï¼Œçº¿ç¨‹æŒ‰ç¼–å·å‡åºç”³è¯·èµ„æº

- **æ­»é”é¿å…**ï¼šğŸ§  è¦æ±‚çº¿ç¨‹äº‹å…ˆå£°æ˜æœ€å¤§èµ„æºéœ€æ±‚ï¼›æ¯æ¬¡åˆ†é…å‰ï¼Œæ¨¡æ‹Ÿåˆ†é…å¹¶æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦ä»å¤„äºâ€œå®‰å…¨çŠ¶æ€â€ï¼Œåªæœ‰å®‰å…¨æ—¶æ‰çœŸæ­£åˆ†é…ï¼Œå¦åˆ™é˜»å¡è¯·æ±‚

- **é“¶è¡Œå®¶ç®—æ³•**ï¼šğŸ’³ ==ä»æ¥æ²¡è€ƒè¿‡å“¦ï¼Œå…¶å®ä¸éš¾ï¼Œçœ‹æˆ‘ç»™ä¸ªä¾‹é¢˜==

    ```text
    // æ•°æ®ç»“æ„
    Available[m]       // æ¯ç§èµ„æºå½“å‰å¯ç”¨å®ä¾‹æ•°
    Max[n][m]          // è¿›ç¨‹ i å¯¹èµ„æº j çš„æœ€å¤§éœ€æ±‚
    Allocation[n][m]   // å½“å‰å·²åˆ†é…ç»™è¿›ç¨‹ i çš„èµ„æº j æ•°é‡
    Need[n][m] = Max â€“ Allocation
    
    // å®‰å…¨æ€§æ£€æŸ¥ï¼ˆSafety Checkï¼‰
    Work = Available;          Finish[i] = false âˆ€i
    æ‰¾åˆ° Finish[i]=false ä¸” Need[i] â‰¤ Work çš„è¿›ç¨‹ i:
      Work += Allocation[i];   Finish[i] = true; é‡å¤
    è‹¥æ‰€æœ‰ Finish[i]=trueï¼Œåˆ™å®‰å…¨
    
    // è¯·æ±‚å¤„ç†ï¼ˆRequestï¼‰
    è‹¥ Request[i] > Need[i] â†’ é”™è¯¯  
    è‹¥ Request[i] > Available â†’ è¿›ç¨‹ç­‰å¾…  
    å¦åˆ™ï¼š
      Available -= Request[i];
      Allocation[i] += Request[i];
      Need[i] -= Request[i];
      æ‰§è¡Œå®‰å…¨æ€§æ£€æŸ¥ï¼š
        å®‰å…¨ â†’ å®Œæˆåˆ†é…
        ä¸å®‰å…¨ â†’ æ¢å¤åŸçŠ¶æ€ï¼Œé˜»å¡è¯·æ±‚
    ```

### English

- **Four Necessary Conditions for Deadlock**:

    1. ğŸ”’ Mutual Exclusion (a resource can be held by only one thread at a time)
    2. ğŸ”„ Hold and Wait (a thread holding at least one resource may request additional resources)
    3. ğŸš« No Preemption (allocated resources cannot be preempted; they must be released voluntarily)
    4. ğŸ” Circular Wait (there exists a set {Tâ‚€, Tâ‚, â€¦, Tâ‚™} such that Tâ‚€ waits for a resource held by Tâ‚, â€¦, Tâ‚™ waits for a resource held by Tâ‚€)

- **Deadlock Prevention**: âš ï¸ Break one of the four conditions

    - âœ‹ Prevent Hold-and-Wait: Require threads to request all needed resources at once or only request when holding none
    - ğŸ”ƒ Prevent No-Preemption: If a request cannot be immediately granted, release all currently held resources and retry later
    - ğŸ§® Prevent Circular Wait: Impose a global ordering on resource types and require threads to acquire resources in increasing order

- **Deadlock Avoidance**: ğŸ§  Threads must declare their maximum resource needs in advance; before each allocation, simulate it and check if the system remains in a â€œsafe state,â€ granting only if safe, otherwise blocking the request

- **Bankerâ€™s Algorithm**: ğŸ’³ ==ä»æ¥æ²¡è€ƒè¿‡å“¦ï¼Œå…¶å®ä¸éš¾ï¼Œçœ‹æˆ‘ç»™ä¸ªä¾‹é¢˜==

    ```text
    // Data structures
    Available[m]       // number of available instances of each resource
    Max[n][m]          // maximum demand of each process
    Allocation[n][m]   // number of instances currently allocated to each process
    Need[n][m] = Max â€“ Allocation
    
    // Safety Check
    Work = Available;          Finish[i] = false âˆ€i
    Find an i such that Finish[i]=false and Need[i] â‰¤ Work:
      Work += Allocation[i];   Finish[i] = true; repeat
    If all Finish[i]=true, the system is safe
    
    // Resource-Request Handling
    If Request[i] > Need[i], error  
    Else if Request[i] > Available, process must wait  
    Else:
      Available -= Request[i]
      Allocation[i] += Request[i]
      Need[i] -= Request[i]
      Perform safety check:
        Safe â†’ grant request
        Unsafe â†’ revert state, block request
    ```



### é“¶è¡Œå®¶ç®—æ³•ä¾‹é¢˜ï¼š

**åœ¨é“¶è¡Œå®¶ç®—æ³•ä¸­ï¼Œè‹¥å‡ºç°ä¸‹è¿°èµ„æºåˆ†é…æƒ…å†µï¼š**

| Process | Allocation | Need    | Available |
| ------- | ---------- | ------- | --------- |
| P0      | 0 0 3 2    | 0 0 1 2 | 1 6 2 2   |
| P1      | 1 0 0 1    | 7 5 0 0 |           |
| P2      | 1 3 5 4    | 2 3 5 6 |           |
| P3      | 0 3 3 2    | 0 6 5 2 |           |
| P4      | 0 0 1 4    | 6 6 5 6 |           |

**æ³¨**ï¼šé¢˜ä¸­å…±å››ç§èµ„æºï¼ŒP0çš„Allocationä¸º(0,0,3,2)è¡¨ç¤ºå·²åˆ†é…ç»™P0çš„ç¬¬ä¸€ç§èµ„æºå’Œç¬¬äºŒç§èµ„æºä¸º0ä¸ªï¼Œç¬¬ä¸‰ç§èµ„æº3ä¸ªï¼Œç¬¬å››ç§èµ„æº2ä¸ªã€‚

1. è¯¥çŠ¶æ€æ˜¯å¦å®‰å…¨ï¼Ÿ
2. æ‰¾åˆ°ä¸€ä¸ªå®‰å…¨åºåˆ—ã€‚
3. è‹¥è¿›ç¨‹P2æå‡ºè¯·æ±‚Request(1,2,2,2)åï¼Œç³»ç»Ÿèƒ½å¦å°†èµ„æºåˆ†é…ç»™å®ƒï¼Ÿ

**English:**

**In the Banker's Algorithm, given the following resource allocation state:**

| Process | Allocation | Need    | Available |
| ------- | ---------- | ------- | --------- |
| P0      | 0 0 3 2    | 0 0 1 2 | 1 6 2 2   |
| P1      | 1 0 0 1    | 7 5 0 0 |           |
| P2      | 1 3 5 4    | 2 3 5 6 |           |
| P3      | 0 3 3 2    | 0 6 5 2 |           |
| P4      | 0 0 1 4    | 6 6 5 6 |           |

**Note:** There are four types of resources in the problem. For example, P0's Allocation (0, 0, 3, 2) indicates that P0 has been allocated 0 units of the first and second resources, 3 units of the third resource, and 2 units of the fourth resource.

1. Is the current state safe?  
2. Find a safe sequence.  
3. If process P2 requests resources as Request(1, 2, 2, 2), can the system safely allocate the resources to it?  



**è§£ç­”ï¼š/ Answer:**

è®°ä½èµ„æºæ€»å’Œæ˜¯å›ºå®šçš„ï¼

1. Safe (0 0 1 2) 

    è§£é‡Šï¼šä¸€èˆ¬éƒ½æ˜¯å®‰å…¨çš„ï¼Œæ¯•ç«Ÿè¦å›ç­”ç¬¬äºŒé—®å‘µå‘µï¼Œåªè¦æ‰¾åˆ°ä¸€ä¸ªNeedèƒ½è¢«Available coverå°±è¡Œ

2. {P0, P3, P4, P1, P2}

    è§£é‡Šï¼šçœ‹ä¸‹é¢è¡¨æ ¼

    åˆå§‹ Available = (1, 6, 2, 2)

    æ‰§è¡Œ P0 ï¼ˆNeedâ‚€=(0,0,1,2) â‰¤ Availableï¼‰ï¼Œé‡Šæ”¾å Available = (1, 6, 2, 2)+(0,0,3,2) = (1, 6, 5, 4)

    æ‰§è¡Œ P3 ï¼ˆNeedâ‚ƒ=(0,6,5,2) â‰¤ (1,6,5,4)ï¼‰ï¼Œé‡Šæ”¾å Available = (1, 6, 5, 4)+(0,3,3,2) = (1, 9, 8, 6)

    æ‰§è¡Œ P4 ï¼ˆNeedâ‚„=(6,6,5,6) â‰¤ (1,9,8,6)ï¼‰â€¦

    ä»¥æ­¤ç±»æ¨ï¼Œæœ€ç»ˆèƒ½è®©æ‰€æœ‰è¿›ç¨‹ä¾æ¬¡å®Œæˆã€‚

    

    å¤§ç™½è¯ï¼šåˆå§‹ Available çš„ 1 6 2 2 åªèƒ½æ»¡è¶³ P0 çš„ Needï¼Œç»™äº† P0 å‰©ä¸‹1 6 1 0ï¼Œexec å®Œè¿˜å›æ¥å…± 1 6 5 4 Availableï¼Œæ¥ç€å‘ç°åªèƒ½æ»¡è¶³ P3 çš„ Need... å¦‚æ­¤å¾€å¤ï¼š

| è¿›ç¨‹ | Allocation(å·²åˆ†é…) | Need        | Available   | Available+Allocation(æ‰§è¡Œå®Œåæ–°Available) | Finish |
| ---- | ------------------ | ----------- | ----------- | ----------------------------------------- | ------ |
| P0   | 0 0 3 2            | 0 0 1 2     | 1 6 2 2     | 1+0, 6+0, 2+3, 2+2 = **1 6 5 4**          | true   |
| P3   | 0 3 3 2            | **0 6 5 2** | **1 6 5 4** | 1 9 8 6                                   | true   |
| P4   | 0 0 1 4            | 0 6 5 6     | 1 9 8 6     | 1 9 9 10                                  | true   |
| P1   | 1 0 0 0            | 1 7 5 0     | 1 9 9 10    | 2 9 9 10                                  | true   |
| P2   | 1 3 5 4            | 2 3 5 6     | 2 9 9 10    | 3 12 14 14                                | true   |

3. No

    è§£é‡Šï¼š

| Process | Allocation | Need    | Available                                  |
| ------- | ---------- | ------- | ------------------------------------------ |
| P2      | 1 3 5 4    | 2 3 5 6 | 1 6 2 2 ==(åˆå§‹ï¼Œè°ä¹Ÿåˆ«ç»™ï¼Œå’Œ1ã€2é¢˜æ— å…³)== |

é¦–å…ˆè®¡ç®—è¯·æ±‚å®Œåçš„æ–°çŠ¶æ€ï¼š

| Process | Allocation æ–°                   | Need æ–°                             | Available æ–°                    |
| ------- | ------------------------------- | ----------------------------------- | ------------------------------- |
| **P2**  | (1,3,5,4)+(1,2,2,2) = (2,5,7,6) | (2,3,5,6)==âˆ’(1,2,2,2)== = (1,1,3,4) | (1,6,2,2)âˆ’(1,2,2,2) = (0,4,0,0) |

å¾—åˆ° New Available = (0, 4, 0, 0)ã€‚æ­¤æ—¶æ£€æŸ¥æ‰€æœ‰è¿›ç¨‹çš„ Needï¼š

- P0: (0,0,1,2) ä¸­ç¬¬ 3ã€4 ç±»èµ„æºéƒ½è¶…è¿‡ New Available â†’ ä¸èƒ½æ‰§è¡Œ
- P1ã€P2ã€P3ã€P4 çš„ Need ç¬¬ä¸€é¡¹å‡>0 â†’ éƒ½ä¸èƒ½æ‰§è¡Œ

å› æ­¤ï¼Œæ²¡æœ‰ä»»ä½•è¿›ç¨‹èƒ½åœ¨è¿™ä¸€ Available ä¸‹å®Œæˆï¼Œç³»ç»Ÿå°†é™·å…¥ä¸å®‰å…¨çŠ¶æ€ã€‚**æ•…ä¸èƒ½æ»¡è¶³ P2 çš„è¯·æ±‚ã€‚**



------

## 5. ğŸ’¾ å†…å­˜åŸºæœ¬æ¦‚å¿µï¼›è™šæ‹Ÿå†…å­˜ï¼›é¡µ/å¸§

### ä¸­æ–‡

- **å†…å­˜ç®¡ç†èŒè´£**ï¼š
    - ğŸ§  è·Ÿè¸ªå“ªäº›å†…å­˜åŒºåŸŸæ­£åœ¨ä½¿ç”¨ã€ç”±å“ªä¸ªè¿›ç¨‹ä½¿ç”¨
    - ğŸ”„ å†³å®šä½•æ—¶å°†å“ªäº›æ•°æ®**æ¢å…¥**æˆ–**æ¢å‡º**å†…å­˜
    - ğŸ§¹ åŠ¨æ€åˆ†é…å’Œå›æ”¶å†…å­˜ç©ºé—´
    - ğŸ›¡ï¸ ä¿è¯å„è¿›ç¨‹éš”ç¦»ï¼Œé˜²æ­¢ç›¸äº’å¹²æ‰°
- **è™šæ‹Ÿå†…å­˜ï¼ˆVirtual Memoryï¼‰**ï¼š
    - ğŸ“ æ¯ä¸ªè¿›ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„ã€å¯è¶…å‡ºç‰©ç†å†…å­˜å¤§å°çš„åœ°å€ç©ºé—´
    - ğŸ—ºï¸ é€šè¿‡åˆ†é¡µï¼ˆPagingï¼‰æœºåˆ¶å®ç°è™šæ‹Ÿâ†’ç‰©ç†åœ°å€æ˜ å°„ï¼Œç”±é¡µè¡¨ç®¡ç†
- **é¡µï¼ˆPageï¼‰ä¸å¸§ï¼ˆFrameï¼‰**ï¼š
    - ğŸ“„ è™šæ‹Ÿåœ°å€ç©ºé—´åˆ’åˆ†ä¸ºå›ºå®šå¤§å°çš„**é¡µ**ï¼ˆå¦‚ 4 KBï¼‰
    - ğŸ“¦ ç‰©ç†å†…å­˜åˆ’åˆ†ä¸ºç›¸åŒå¤§å°çš„**å¸§**
    - ğŸ“‹ **é¡µè¡¨**è®°å½•æ¯ä¸ªè™šæ‹Ÿé¡µå¯¹åº”çš„ç‰©ç†å¸§å·
    - ğŸ’¥ å‘ç”Ÿ**ç¼ºé¡µä¸­æ–­ï¼ˆPage Faultï¼‰**æ—¶ï¼ŒOS å°†æ‰€éœ€é¡µä»ç£ç›˜åŠ è½½åˆ°ç©ºé—²å¸§

### English

- **Memory Management Responsibilities**:
    - ğŸ§  Keep track of which memory regions are in use and by which process
    - ğŸ”„ Decide which data to swap in or out of main memory
    - ğŸ§¹ Allocate and free memory space dynamically
    - ğŸ›¡ï¸ Ensure process isolation and protect against interference
- **Virtual Memory**:
    - ğŸ“ Provides each process with its own address space, which can exceed physical memory size
    - ğŸ—ºï¸ Implemented via **paging**, mapping virtual addresses to physical frames using a page table
- **Pages & Frames**:
    - ğŸ“„ Virtual memory is divided into fixedâ€size **pages** (e.g., 4 KB)
    - ğŸ“¦ Physical memory is divided into identicalâ€sized **frames**
    - ğŸ“‹ A **page table** records the mapping from pages to frames
    - ğŸ’¥ On a **page fault**, the OS loads the required page from disk into a free frame



------

# ğŸ“ ==å¾€å¹´äº”é“é¢˜ç›®==

------

### 1. ğŸ“¨ ç®€è¿°ä¸¤ç§è¿›ç¨‹é€šä¿¡çš„ model (2 åˆ†)

**ä¸­æ–‡**

- ğŸ§± **å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰**ï¼šå¤šä¸ªè¿›ç¨‹å°†åŒä¸€å—ç‰©ç†å†…å­˜æ˜ å°„åˆ°å„è‡ªçš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œé€šè¿‡åœ¨è¯¥å†…å­˜åŒºç›´æ¥è¯»å†™æ¥äº¤æ¢æ•°æ®ã€‚
- âœ‰ï¸ **æ¶ˆæ¯ä¼ é€’ï¼ˆMessage Passingï¼‰**ï¼šè¿›ç¨‹é€šè¿‡ `send(message)`ï¼`receive(message)` åŸè¯­ï¼Œå°†æ¶ˆæ¯æ”¾å…¥æˆ–å–å‡ºå†…æ ¸ç»´æŠ¤çš„é‚®ç®±ï¼ˆportï¼‰æˆ–é˜Ÿåˆ—ä¸­ï¼Œä»¥æ­¤è¿›è¡Œé€šä¿¡å’ŒåŒæ­¥ã€‚

**English**

- ğŸ§± **Shared Memory**: Processes map a common physical memory region into their address spaces and exchange data by direct reads and writes to that region.
- âœ‰ï¸ **Message Passing**: Processes communicate by executing primitives such as `send(P, msg)` / `receive(Q, msg)` through mailboxes (ports) or queues managed by the OS, enabling both data exchange and synchronization.

------

### 2. ğŸ§µ ç®€è¿°è¿›ç¨‹å’Œçº¿ç¨‹çš„å…³ç³» (4 åˆ†)

**ä¸­æ–‡**

- çº¿ç¨‹ï¼ˆThreadï¼‰ä¹Ÿç§°â€œè½»é‡çº§è¿›ç¨‹â€ï¼Œæ˜¯è¿›ç¨‹å†…çš„æœ€å°æ‰§è¡Œå•å…ƒã€‚
- åŒä¸€è¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹å…±äº«è¯¥è¿›ç¨‹çš„åœ°å€ç©ºé—´å’Œå¤§éƒ¨åˆ†èµ„æºï¼ˆå¦‚æ‰“å¼€çš„æ–‡ä»¶ã€å…¨å±€å˜é‡ï¼‰ï¼Œä½†å„è‡ªæ‹¥æœ‰ç‹¬ç«‹çš„æ ˆå’Œå¯„å­˜å™¨é›†ã€‚
- è¿›ç¨‹ï¼ˆProcessï¼‰æ˜¯èµ„æºåˆ†é…çš„åŸºæœ¬å•ä½ï¼Œçº¿ç¨‹æ˜¯è°ƒåº¦å’Œè¿è¡Œçš„åŸºæœ¬å•ä½ã€‚
- æ¯ä¸ªçº¿ç¨‹å¿…å±äºå”¯ä¸€çš„è¿›ç¨‹ï¼Œçº¿ç¨‹æ— æ³•è„±ç¦»è¿›ç¨‹å•ç‹¬å­˜åœ¨ã€‚

**English**

- A thread (lightweight process) is the smallest unit of execution within a process.
- Threads of the same process share the processâ€™s address space and resources (e.g., open files, global data), but each has its own stack and register context.
- A process is the fundamental unit for resource allocation, while threads are the units for CPU scheduling and execution.
- Each thread belongs to exactly one process and cannot exist independently of its process.

------

### 3. ğŸ” ç®€è¿°ä¸‰ç§å¸¸è§çš„è¿›ç¨‹ state model (4 åˆ†)

**ä¸­æ–‡**

1. ğŸŸ¢ **äºŒæ€æ¨¡å‹ï¼ˆTwo-Stateï¼‰**ï¼šä»…åŒ…å«â€œè¿è¡Œï¼ˆRunningï¼‰â€å’Œâ€œéè¿è¡Œï¼ˆNot Runningï¼‰â€ä¸¤ç§çŠ¶æ€ã€‚
2. ğŸŸ¡ **ä¸‰æ€æ¨¡å‹ï¼ˆThree-Stateï¼‰**ï¼šåŒ…æ‹¬â€œå°±ç»ªï¼ˆReadyï¼‰â€ã€â€œè¿è¡Œï¼ˆRunningï¼‰â€å’Œâ€œé˜»å¡/ç­‰å¾…ï¼ˆBlocked/Waitingï¼‰â€ä¸‰ç§çŠ¶æ€ï¼Œç”¨äºè¡¨ç¤ºè¿›ç¨‹æ˜¯å¦åœ¨ç­‰å¾…èµ„æºæˆ–å¯è¢«è°ƒåº¦ã€‚
3. ğŸ”µ **äº”æ€æ¨¡å‹ï¼ˆFive-Stateï¼‰**ï¼šè¿›ä¸€æ­¥ç»†åˆ†ä¸ºâ€œæ–°å»ºï¼ˆNewï¼‰â†’ å°±ç»ªï¼ˆReadyï¼‰â†’ è¿è¡Œï¼ˆRunningï¼‰â†’ ç­‰å¾…/é˜»å¡ï¼ˆWaitingï¼‰â†’ ç»ˆæ­¢ï¼ˆTerminatedï¼‰â€äº”ä¸ªçŠ¶æ€ï¼Œå¹¶ç”¨ä¸­æ–­æˆ–äº‹ä»¶è§¦å‘çŠ¶æ€è½¬æ¢ã€‚

**English**

1. ğŸŸ¢ **Two-State Model**: Only â€œRunningâ€ and â€œNot Running.â€
2. ğŸŸ¡ **Three-State Model**: â€œReady,â€ â€œRunning,â€ and â€œBlocked/Waiting,â€ indicating whether a process is ready to run, currently executing, or waiting for an event/resource.
3. ğŸ”µ **Five-State Model**: â€œNew â†’ Ready â†’ Running â†’ Waiting/Blocked â†’ Terminated,â€ with transitions driven by scheduling, interrupts, and I/O completions.

------

### 4. â±ï¸ è€ƒæŸ¥ FCFSã€SJF çš„ç­‰å¾…æ—¶é—´ (9 åˆ†)

ä¸‹é¢ä¸æ˜¯è€ƒè¯•é¢˜ï¼Œè€Œæ˜¯è¯¾å ‚ç»ƒä¹ ï¼Œéƒ½å·®ä¸å¤šï¼Œä½†æ˜¯è¦çŸ¥é“ï¼š

| ä¸­æ–‡æœ¯è¯­     | è‹±æ–‡æœ¯è¯­                      | è¯´æ˜                                                         |
| ------------ | ----------------------------- | ------------------------------------------------------------ |
| æŠ¢å å¼è°ƒåº¦   | **Preemptive Scheduling**     | æ“ä½œç³»ç»Ÿå¯ä»¥ä¸­æ–­æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ä»¥è°ƒåº¦å…¶ä»–æ›´é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚   |
| éæŠ¢å å¼è°ƒåº¦ | **Non-preemptive Scheduling** | ä¸€æ—¦è¿›ç¨‹å¼€å§‹æ‰§è¡Œï¼Œç³»ç»Ÿä¸ä¼šå¼ºåˆ¶ä¸­æ–­å®ƒï¼Œç›´åˆ°å®ƒå®Œæˆæˆ–ä¸»åŠ¨æ”¾å¼ƒã€‚ |

ğŸ“˜ Chapter 5: CPU Scheduling

------

ğŸ”¹ Problem 5.3 (Page 253)

> Suppose that the following processes arrive for execution at the times indicated. Each process will run for the amount of time listed.
>
> | Process | Arrival Time | Burst Time |
> | ------- | ------------ | ---------- |
> | P1      | 0.0          | 8          |
> | P2      | 0.4          | 4          |
> | P3      | 1.0          | 1          |
>
> 1. What is the average turnaround time for these processes with the FCFS scheduling algorithm?
> 2. What is the average turnaround time for these processes with the SJF scheduling algorithm?
> 3. What is the average turnaround time if the CPU is idle for the first 1.0 time unit, and then SJF is used?

------

âœ… Answer:

1. FCFS (First-Come, First-Served)

Execution order: P1 â†’ P2 â†’ P3

- P1 finishes at 8
- P2 starts at 8, ends at 12
- P3 starts at 12, ends at 13
- Turnaround times:
    - P1: 8 - 0 = 8
    - P2: 12 - 0.4 = 11.6
    - P3: 13 - 1.0 = 12

**Average Turnaround Time = (8 + 11.6 + 12) / 3 = 10.53**

```
1. FCFS (First-Come, First-Served)
|   P1   |  P2  | P3 |
0        8      12   13
```

------

2. SJF (Shortest Job First, non-preemptive)

Since only P1 is available at time 0, it must run first.
 Then shortest available jobs are chosen: P3 â†’ P2

- Finish times: P1=8, P3=9, P2=13
- Turnaround times:
    - P1: 8
    - P3: 9 - 1 = 8
    - P2: 13 - 0.4 = 12.6

**Average Turnaround Time = (8 + 8 + 12.6) / 3 = 9.53**

```
2. SJF (Shortest Job First)
|   P1   | P3 |  P2  |
0        8    9      13
```

------

3. Delayed SJF (Idle until 1.0, then use SJF)

Idle CPU until 1.0; all processes are now known.
 Use SJF: P3 â†’ P2 â†’ P1

- Finish times: P3=2, P2=6, P1=14
- Turnaround times:
    - P3: 2 - 1 = 1
    - P2: 6 - 0.4 = 5.6
    - P1: 14 - 0 = 14

**Average Turnaround Time = (1 + 5.6 + 14) / 3 = 6.87**

```
3. Delayed SJF (Idle until t=1.0)
| idle | P3 |  P2  |      P1      |
0      1    2      6              14
```

------

ğŸ“Œ Summary (Problem 5.3):

| Algorithm   | Avg. Turnaround Time |
| ----------- | -------------------- |
| FCFS        | 10.53                |
| SJF         | 9.53                 |
| Delayed SJF | ğŸ¥‡ 6.87               |

------

ğŸ”¹ Problem 5.4 (Page 253)

> Consider the following set of processes, with the length of the CPU burst time and priority:
>
> | Process | Burst Time | Priority |
> | ------- | ---------- | -------- |
> | P1      | 2          | 2        |
> | P2      | 1          | 1        |
> | P3      | 8          | 4        |
> | P4      | 4          | 2        |
> | P5      | 5          | 3        |
>
> All processes arrive at time 0.
>
> 1. Draw four Gantt charts: FCFS, SJF, non-preemptive priority (higher number = higher priority), and RR (quantum = 2)
> 2. What is the turnaround time of each process for each algorithm?
> 3. What is the waiting time of each process for each algorithm?
> 4. Which algorithm gives the minimum average waiting time?

------

âœ… Answer:

1. FCFS (First-Come, First-Served)

Order: P1 â†’ P2 â†’ P3 â†’ P4 â†’ P5
 Finish times: P1=2, P2=3, P3=11, P4=15, P5=20
 Waiting times: 0, 2, 3, 11, 15
 **Average Waiting Time = 6.2**

```
1. FCFS (First-Come, First-Served)
| P1 | P2 |    P3    |  P4  |  P5  |
0    2    3          11     15     20
```

------

2. SJF (Shortest Job First)

Order: P2 â†’ P1 â†’ P4 â†’ P5 â†’ P3
 Finish times: P2=1, P1=3, P4=7, P5=12, P3=20
 Waiting times: 0, 1, 3, 7, 12
 **Average Waiting Time = ğŸ¥‡ 4.6**

```
2. SJF (Shortest Job First)
| P2 | P1 |  P4  |  P5  |    P3    |
0    1    3     7      12         20
```

------

3. Non-preemptive Priority (higher number = higher priority)

Order: P3 â†’ P5 â†’ P1 â†’ P4 â†’ P2
 Finish times: P3=8, P5=13, P1=15, P4=19, P2=20
 Waiting times: 0, 8, 13, 15, 19
 **Average Waiting Time = 11.0**

```
3. Non-preemptive Priority (higher = higher priority)
|    P3    |  P5  | P1 |  P4  | P2 |
0          8      13   15     19   20
```

------

4. Round Robin (Q=2)

Approximate execution sequence with quantum=2:
 Finish times: P1=2, P2=3, P3=20, P4=15, P5=18
 Waiting times: 0, 2, 12, 11, 13
 **Average Waiting Time â‰ˆ 7.6**

```
4. RR (Quantum = 2)
|P1|P2|P3|P4|P5|P3|P4|P5|P3|P5|P3|
0  2  3  5  7  9  11 13 15 17 18 20
```

------

ğŸ“Œ Summary (Problem 5.4):

| Algorithm | Avg. Waiting Time | Avg. Turnaround Time (approx) |
| --------- | ----------------- | ----------------------------- |
| FCFS      | 6.2               | 10.2                          |
| SJF       | ğŸ¥‡ 4.6             | 8.6                           |
| Priority  | 11.0              | 15.0                          |
| RR (Q=2)  | 7.6               | 11.6                          |



------

### 5. ğŸ“¶ å†™ä¿¡å·é‡çš„ P/V æ“ä½œä¼ªä»£ç ï¼Œå¯ä»¥å‡è®¾æœ‰ thread_hold(), thread_signal() (6 åˆ†)

**ä¸­æ–‡**

```c
// P(S) ç­‰ä»· wait(S)
P(semaphore *S) {
    S->value--;
    if (S->value < 0) {
        add_this_thread_to(S->list);
        thread_hold();    // é˜»å¡å½“å‰çº¿ç¨‹
    }
}

// V(S) ç­‰ä»· signal(S)
V(semaphore *S) {
    S->value++;
    if (S->value <= 0) {
        thread t = remove_thread_from(S->list);
        thread_signal(t); // å”¤é†’è¢«é˜»å¡çº¿ç¨‹
    }
}
```

è¯¥ä¼ªä»£ç åŸºäºè¯¾ä»¶ç¬¬6ç« ä¿¡å·é‡å®ç°ï¼Œæ— å¿™ç­‰ï¼Œå†…éƒ¨ä½¿ç”¨ç­‰å¾…é˜Ÿåˆ—ç®¡ç†é˜»å¡å’Œå”¤é†’ã€‚

**English**

```c
// P(S) equivalent to wait(S)
void P(semaphore *S) {
    S->value--;
    if (S->value < 0) {
        add_this_thread_to(S->list);
        thread_hold();    // block current thread
    }
}

// V(S) equivalent to signal(S)
void V(semaphore *S) {
    S->value++;
    if (S->value <= 0) {
        thread t = remove_thread_from(S->list);
        thread_signal(t); // wake up a blocked thread
    }
}
```

This code uses a waiting queue to avoid busy-waiting, blocking and waking threads via `thread_hold()` and `thread_signal()`.

------

## è®¡ç§‘2302èƒ¡å¾·ä¸œç¥ä½ è€ƒè¯•å¿…èƒœï¼ğŸ“šğŸ”¥

(æ‰€æœ‰å†…å®¹ä¸¥æ ¼æŒ‰ç…§è¯¾ä»¶æ’°å†™)